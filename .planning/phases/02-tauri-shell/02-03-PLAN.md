---
phase: 02-tauri-shell
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - apps/desktop/src-tauri/src/types/config.rs
  - apps/desktop/src-tauri/src/types/mod.rs
  - apps/desktop/src-tauri/src/services/mcp_manager.rs
  - apps/desktop/src-tauri/src/services/config_loader.rs
  - apps/desktop/src-tauri/src/services/mod.rs
  - apps/desktop/src-tauri/src/commands/mcp.rs
  - apps/desktop/src-tauri/src/commands/mod.rs
autonomous: true

must_haves:
  truths:
    - "MCP config file can be loaded in Claude Desktop-compatible format"
    - "MCP server process can be started on demand via IPC command"
    - "MCP server process can be stopped via IPC command"
    - "Running MCP servers are tracked with status"
    - "MCP server auto-restarts on crash with backoff (3 retries max)"
    - "All child processes killed when app exits"
  artifacts:
    - path: "apps/desktop/src-tauri/src/types/config.rs"
      provides: "MCP config types (McpConfig, McpServerConfig)"
      contains: "mcpServers"
    - path: "apps/desktop/src-tauri/src/services/mcp_manager.rs"
      provides: "Process lifecycle manager with backoff"
      contains: "kill_on_drop"
    - path: "apps/desktop/src-tauri/src/commands/mcp.rs"
      provides: "IPC commands for MCP server management"
      contains: "tauri::command"
  key_links:
    - from: "apps/desktop/src-tauri/src/services/mcp_manager.rs"
      to: "tokio::process::Command"
      via: "spawn with kill_on_drop"
      pattern: "kill_on_drop.*true"
    - from: "apps/desktop/src-tauri/src/services/config_loader.rs"
      to: "types::config::McpConfig"
      via: "serde_json deserialization"
      pattern: "serde_json::from_str"
---

<objective>
Implement MCP server configuration loading and process lifecycle management with lazy startup, auto-restart with backoff, and clean shutdown.

Purpose: Enables the app to manage MCP server processes that agents will use for tool access. The config format is Claude Desktop-compatible so users can reuse existing MCP server configurations.
Output: Working MCP server start/stop/list IPC commands with process lifecycle management.
</objective>

<execution_context>
@/Users/neosapien/.claude/get-shit-done/workflows/execute-plan.md
@/Users/neosapien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-tauri-shell/02-CONTEXT.md
@.planning/phases/02-tauri-shell/02-RESEARCH.md
@.planning/phases/02-tauri-shell/02-01-SUMMARY.md
@apps/desktop/src-tauri/src/types/errors.rs
@apps/desktop/src-tauri/src/state.rs
@apps/desktop/src-tauri/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: MCP config types and config loader</name>
  <files>
    apps/desktop/src-tauri/src/types/config.rs
    apps/desktop/src-tauri/src/types/mod.rs
    apps/desktop/src-tauri/src/services/config_loader.rs
    apps/desktop/src-tauri/src/services/mod.rs
  </files>
  <action>
    1. Create src/types/config.rs:
       - McpServerConfig: { command: String, args: Vec<String>, env: HashMap<String, String> (with serde default) }
       - McpConfig: { mcp_servers: HashMap<String, McpServerConfig> } with #[serde(rename = "mcpServers")]
       - Derive Debug, Deserialize, Serialize on both
       - McpServerStatus enum: Stopped, Starting, Running, Failed(String) -- derives Serialize for IPC

    2. Update src/types/mod.rs to expose config module.

    3. Create src/services/config_loader.rs:
       - load(path: &Path) -> Result<McpConfig, AppError> -- reads JSON file, deserializes
       - save(config: &McpConfig, path: &Path) -> Result<(), AppError> -- serializes pretty, writes
       - default_config_path(app_data_dir: &Path) -> PathBuf -- returns app_data_dir/mcp_servers.json
       - If config file doesn't exist, create it with empty mcpServers object

    4. Update src/services/mod.rs to expose config_loader.
  </action>
  <verify>
    `cd /Users/neosapien/dev/aios/apps/desktop/src-tauri && cargo check` compiles.
  </verify>
  <done>McpConfig types match Claude Desktop format. Config loader reads/writes JSON. Default empty config created if missing.</done>
</task>

<task type="auto">
  <name>Task 2: MCP process manager and IPC commands</name>
  <files>
    apps/desktop/src-tauri/src/services/mcp_manager.rs
    apps/desktop/src-tauri/src/services/mod.rs
    apps/desktop/src-tauri/src/commands/mcp.rs
    apps/desktop/src-tauri/src/commands/mod.rs
  </files>
  <action>
    1. Create src/services/mcp_manager.rs:
       - McpManager struct holding:
         a. config: McpConfig (loaded config)
         b. processes: HashMap<String, tokio::process::Child> (running server processes)
         c. statuses: HashMap<String, McpServerStatus>
       - Methods:
         a. new(config: McpConfig) -> Self
         b. start_server(&mut self, name: &str, secrets: &HashMap<String, String>) -> Result<(), AppError>
            - Look up server in config by name
            - Merge server env with provided secrets (secrets override)
            - Spawn with tokio::process::Command, .kill_on_drop(true), stdout/stderr piped
            - Store Child handle in processes map
            - On spawn failure, retry with backoff crate (ExponentialBackoff, max 3 retries)
            - Update status accordingly
         c. stop_server(&mut self, name: &str) -> Result<(), AppError>
            - Kill the child process, remove from map
         d. list_servers(&self) -> Vec<ServerInfo> where ServerInfo = { name, status, config }
         e. stop_all(&mut self) -- stops all running servers (called on app shutdown)

    2. Update src/services/mod.rs to expose mcp_manager.

    3. Create src/commands/mcp.rs with IPC commands:
       - start_mcp_server(state, name: String) -> Result<(), AppError>
       - stop_mcp_server(state, name: String) -> Result<(), AppError>
       - list_mcp_servers(state) -> Result<Vec<ServerInfo>, AppError>
       - All use State<'_, Mutex<AppState>> injection

    4. Update src/commands/mod.rs to expose mcp module.

    NOTE: The actual wiring into lib.rs (adding MCP commands to generate_handler!, adding McpManager to AppState, registering shutdown hook) will be done in a separate integration step. Since plan 02 also modifies lib.rs and state.rs, one of the two plans should handle the final wiring. Plan 02 handles lib.rs wiring for secrets. The executor of THIS plan should:
    - NOT modify lib.rs or state.rs directly (plan 02 owns those files this wave)
    - Instead, ensure all types and services compile independently
    - Add TODO comments in mcp.rs noting that lib.rs wiring is needed

    The execute-phase workflow will handle the integration. If plans 02 and 03 run sequentially (likely), the second one to run should add both sets of commands to generate_handler!.
  </action>
  <verify>
    `cd /Users/neosapien/dev/aios/apps/desktop/src-tauri && cargo check` compiles (may need conditional compilation or the executor may need to wire into lib.rs after all -- if so, update state.rs and lib.rs as needed to make it compile).
  </verify>
  <done>McpManager can spawn/stop/list MCP server processes. Backoff retry logic implemented. kill_on_drop(true) prevents zombies. IPC commands exist for start/stop/list.</done>
</task>

</tasks>

<verification>
1. `cargo check` passes
2. McpConfig deserializes Claude Desktop-compatible JSON format
3. McpManager tracks process lifecycle with status
4. Backoff retry logic compiles (functional test deferred to integration)
5. kill_on_drop(true) set on all spawned processes
</verification>

<success_criteria>
- MCP config types match Claude Desktop mcpServers format
- Config loader creates default empty config if missing
- McpManager spawns processes with kill_on_drop(true)
- Auto-restart with exponential backoff (max 3 retries)
- Start/stop/list IPC commands exist
- No zombie process risk (kill_on_drop pattern)
</success_criteria>

<output>
After completion, create `.planning/phases/02-tauri-shell/02-03-SUMMARY.md`
</output>
