---
phase: 02-tauri-shell
plan: 03
type: execute
wave: 3
depends_on: ["02-01", "02-02"]
files_modified:
  - apps/desktop/src-tauri/src/types/config.rs
  - apps/desktop/src-tauri/src/types/mod.rs
  - apps/desktop/src-tauri/src/services/mcp_manager.rs
  - apps/desktop/src-tauri/src/services/config_loader.rs
  - apps/desktop/src-tauri/src/services/mod.rs
  - apps/desktop/src-tauri/src/commands/mcp.rs
  - apps/desktop/src-tauri/src/commands/mod.rs
  - apps/desktop/src-tauri/src/state.rs
  - apps/desktop/src-tauri/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "MCP config file can be loaded in Claude Desktop-compatible format"
    - "MCP server process can be started on demand via IPC command"
    - "MCP server process can be stopped via IPC command"
    - "Running MCP servers are tracked with status"
    - "MCP server auto-restarts on crash with backoff (3 retries max)"
    - "All child processes killed when app exits"
    - "Empty MCP config created on first launch if missing"
    - "MCP config persists across restarts"
  artifacts:
    - path: "apps/desktop/src-tauri/src/types/config.rs"
      provides: "MCP config types (McpConfig, McpServerConfig)"
      contains: "mcpServers"
    - path: "apps/desktop/src-tauri/src/services/mcp_manager.rs"
      provides: "Process lifecycle manager with backoff"
      contains: "kill_on_drop"
    - path: "apps/desktop/src-tauri/src/commands/mcp.rs"
      provides: "IPC commands for MCP server management"
      contains: "tauri::command"
  key_links:
    - from: "apps/desktop/src-tauri/src/services/mcp_manager.rs"
      to: "tokio::process::Command"
      via: "spawn with kill_on_drop"
      pattern: "kill_on_drop.*true"
    - from: "apps/desktop/src-tauri/src/services/config_loader.rs"
      to: "types::config::McpConfig"
      via: "serde_json deserialization"
      pattern: "serde_json::from_str"
    - from: "apps/desktop/src-tauri/src/commands/mcp.rs"
      to: "services::keyring_service::KeyringService"
      via: "secrets retrieval for env vars"
      pattern: "get_secret\\|list_keys"
---

<objective>
Implement MCP server configuration loading and process lifecycle management with lazy startup, auto-restart with backoff, and clean shutdown. Now runs after plan 02 so it can directly wire into lib.rs, state.rs, and access KeyringService for passing secrets as env vars.

Purpose: Enables the app to manage MCP server processes that agents will use for tool access. The config format is Claude Desktop-compatible so users can reuse existing MCP server configurations.
Output: Working MCP server start/stop/list IPC commands with process lifecycle management, wired into lib.rs.
</objective>

<execution_context>
@/Users/neosapien/.claude/get-shit-done/workflows/execute-plan.md
@/Users/neosapien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-tauri-shell/02-CONTEXT.md
@.planning/phases/02-tauri-shell/02-RESEARCH.md
@.planning/phases/02-tauri-shell/02-01-SUMMARY.md
@.planning/phases/02-tauri-shell/02-02-SUMMARY.md
@apps/desktop/src-tauri/src/types/errors.rs
@apps/desktop/src-tauri/src/state.rs
@apps/desktop/src-tauri/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: MCP config types and config loader</name>
  <files>
    apps/desktop/src-tauri/src/types/config.rs
    apps/desktop/src-tauri/src/types/mod.rs
    apps/desktop/src-tauri/src/services/config_loader.rs
    apps/desktop/src-tauri/src/services/mod.rs
  </files>
  <action>
    1. Create src/types/config.rs:
       - McpServerConfig: { command: String, args: Vec<String>, env: HashMap<String, String> (with serde default) }
       - McpConfig: { mcp_servers: HashMap<String, McpServerConfig> } with #[serde(rename = "mcpServers")]
       - Derive Debug, Deserialize, Serialize on both
       - McpServerStatus enum: Stopped, Starting, Running, Failed(String) -- derives Serialize for IPC

    2. Update src/types/mod.rs to expose config module.

    3. Create src/services/config_loader.rs:
       - load(path: &Path) -> Result<McpConfig, AppError> -- reads JSON file, deserializes
       - save(config: &McpConfig, path: &Path) -> Result<(), AppError> -- serializes pretty, writes
       - default_config_path(app_data_dir: &Path) -> PathBuf -- returns app_data_dir/mcp_servers.json
       - If config file doesn't exist, create it with empty mcpServers object

    4. Update src/services/mod.rs to expose config_loader.
  </action>
  <verify>
    `cd /Users/neosapien/dev/aios/apps/desktop/src-tauri && cargo check` compiles.
  </verify>
  <done>McpConfig types match Claude Desktop format. Config loader reads/writes JSON. Default empty config created if missing.</done>
</task>

<task type="auto">
  <name>Task 2: MCP process manager, IPC commands, and wiring into lib.rs</name>
  <files>
    apps/desktop/src-tauri/src/services/mcp_manager.rs
    apps/desktop/src-tauri/src/services/mod.rs
    apps/desktop/src-tauri/src/commands/mcp.rs
    apps/desktop/src-tauri/src/commands/mod.rs
    apps/desktop/src-tauri/src/state.rs
    apps/desktop/src-tauri/src/lib.rs
  </files>
  <action>
    1. Create src/services/mcp_manager.rs:
       - McpManager struct holding:
         a. config: McpConfig (loaded config)
         b. processes: HashMap<String, tokio::process::Child> (running server processes)
         c. statuses: HashMap<String, McpServerStatus>
       - Methods:
         a. new(config: McpConfig) -> Self
         b. start_server(&mut self, name: &str, env_overrides: HashMap<String, String>) -> Result<(), AppError>
            - Look up server in config by name
            - Merge server env with env_overrides (overrides win)
            - Spawn with tokio::process::Command, .kill_on_drop(true), stdout/stderr piped
            - Store Child handle in processes map
            - On spawn failure, retry with backoff crate (ExponentialBackoff, max 3 retries)
            - Update status accordingly
         c. stop_server(&mut self, name: &str) -> Result<(), AppError>
            - Kill the child process, remove from map
         d. list_servers(&self) -> Vec<ServerInfo> where ServerInfo = { name, status, config }
         e. stop_all(&mut self) -- stops all running servers (called on app shutdown)

    2. Update src/services/mod.rs to expose mcp_manager.

    3. Create src/commands/mcp.rs with IPC commands:
       - start_mcp_server(state, name: String) -> Result<(), AppError>
         IMPORTANT: This command must retrieve ALL secrets from KeyringService (via state.keyring.list_keys() + get_secret for each) and pass them as env_overrides to McpManager.start_server(). This ensures MCP servers have access to API keys stored in the keyring.
       - stop_mcp_server(state, name: String) -> Result<(), AppError>
       - list_mcp_servers(state) -> Result<Vec<ServerInfo>, AppError>
       - All use State<'_, Mutex<AppState>> injection

    4. Update src/commands/mod.rs to expose mcp module.

    5. Update src/state.rs: Add McpManager field to AppState.

    6. Update src/lib.rs:
       - Load MCP config from default path (app data dir) in setup closure, create empty if missing
       - Initialize McpManager with loaded config and add to AppState
       - Add MCP commands to generate_handler! (alongside health_check and secrets commands):
         commands::mcp::start_mcp_server, commands::mcp::stop_mcp_server, commands::mcp::list_mcp_servers
       - Add on_window_event or app exit hook to call mcp_manager.stop_all() for clean shutdown

    7. Update capabilities/default.json with allow permissions for MCP commands.
  </action>
  <verify>
    `cd /Users/neosapien/dev/aios/apps/desktop/src-tauri && cargo build` succeeds. All MCP commands registered alongside existing health and secrets commands.
  </verify>
  <done>McpManager wired into AppState. start_mcp_server retrieves secrets from KeyringService and passes as env vars. All commands registered in single generate_handler!. Shutdown hook calls stop_all().</done>
</task>

</tasks>

<verification>
1. `cargo check` passes
2. McpConfig deserializes Claude Desktop-compatible JSON format
3. McpManager tracks process lifecycle with status
4. start_mcp_server retrieves secrets from KeyringService and passes to McpManager
5. Backoff retry logic compiles (functional test deferred to integration)
6. kill_on_drop(true) set on all spawned processes
7. Empty mcp_servers.json created on first launch if missing
8. All commands (health, secrets, MCP) in single generate_handler!
</verification>

<success_criteria>
- MCP config types match Claude Desktop mcpServers format
- Config loader creates default empty config if missing
- McpManager spawns processes with kill_on_drop(true)
- Auto-restart with exponential backoff (max 3 retries)
- start_mcp_server passes keyring secrets as env vars to spawned processes
- Start/stop/list IPC commands exist and are registered
- No zombie process risk (kill_on_drop pattern)
- MCP config file persists across restarts
</success_criteria>

<output>
After completion, create `.planning/phases/02-tauri-shell/02-03-SUMMARY.md`
</output>
