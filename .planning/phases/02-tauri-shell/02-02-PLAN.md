---
phase: 02-tauri-shell
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - apps/desktop/src-tauri/src/services/mod.rs
  - apps/desktop/src-tauri/src/services/keyring_service.rs
  - apps/desktop/src-tauri/src/commands/secrets.rs
  - apps/desktop/src-tauri/src/state.rs
  - apps/desktop/src-tauri/src/lib.rs
  - apps/desktop/src-tauri/src/commands/mod.rs
  - apps/desktop/src-tauri/capabilities/default.json
autonomous: true

must_haves:
  truths:
    - "Secrets can be stored in system keyring via IPC command"
    - "Secrets can be retrieved from system keyring via IPC command"
    - "Secrets can be deleted from system keyring via IPC command"
    - "All stored secrets can be listed"
    - "SQLite database initializes on first launch with runs and messages tables"
  artifacts:
    - path: "apps/desktop/src-tauri/src/services/keyring_service.rs"
      provides: "Keyring wrapper with CRUD operations"
      contains: "keyring::Entry"
    - path: "apps/desktop/src-tauri/src/commands/secrets.rs"
      provides: "IPC commands for secrets management"
      contains: "tauri::command"
  key_links:
    - from: "apps/desktop/src-tauri/src/commands/secrets.rs"
      to: "services::keyring_service::KeyringService"
      via: "State injection"
      pattern: "State.*AppState"
    - from: "apps/desktop/src-tauri/src/lib.rs"
      to: "commands::secrets"
      via: "generate_handler! macro"
      pattern: "generate_handler!"
---

<objective>
Implement secrets management via system keyring and SQLite database initialization with schema for runs and messages.

Purpose: Provides secure credential storage for MCP server environment variables and establishes the persistence layer for agent run tracking.
Output: Working keyring IPC commands (get/set/delete/list secrets) and SQLite database with initial schema.
</objective>

<execution_context>
@/Users/neosapien/.claude/get-shit-done/workflows/execute-plan.md
@/Users/neosapien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-tauri-shell/02-CONTEXT.md
@.planning/phases/02-tauri-shell/02-RESEARCH.md
@.planning/phases/02-tauri-shell/02-01-SUMMARY.md
@apps/desktop/src-tauri/src/types/errors.rs
@apps/desktop/src-tauri/src/state.rs
@apps/desktop/src-tauri/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Keyring service and secrets IPC commands</name>
  <files>
    apps/desktop/src-tauri/src/services/mod.rs
    apps/desktop/src-tauri/src/services/keyring_service.rs
    apps/desktop/src-tauri/src/commands/secrets.rs
    apps/desktop/src-tauri/src/commands/mod.rs
    apps/desktop/src-tauri/src/state.rs
  </files>
  <action>
    1. Create src/services/mod.rs exposing keyring_service.

    2. Create src/services/keyring_service.rs:
       - KeyringService struct with service_name: String
       - Constructor: new(service_name: &str) -> Self
       - Methods:
         a. set_secret(key: &str, value: &str) -> Result<(), AppError> -- uses keyring::Entry::new
         b. get_secret(key: &str) -> Result<String, AppError> -- returns password
         c. delete_secret(key: &str) -> Result<(), AppError> -- uses delete_credential
         d. list_keys(&self) -> Vec<String> -- returns list of known keys from internal tracking
       - For list_keys: keyring crate has no "list all" API. Maintain a Vec<String> of known key names inside KeyringService (wrapped in the same Mutex as the service). When set_secret is called, add key to list. When delete_secret, remove. Persist the key list to a JSON file in app data dir for survival across restarts.
       - Service name: "com.aios.secrets" (distinct from bundle ID to avoid confusion)

    3. Create src/commands/secrets.rs with IPC commands (all snake_case):
       - get_secrets(state) -> Result<Vec<SecretEntry>, AppError> -- returns all secrets as {key, value} pairs
       - get_secret(state, key: String) -> Result<String, AppError>
       - set_secret(state, key: String, value: String) -> Result<(), AppError>
       - delete_secret(state, key: String) -> Result<(), AppError>
       - SecretEntry is a struct with key: String, value: String, derives Serialize

    4. Update src/state.rs: Add KeyringService field to AppState (wrapped in std::sync::Mutex for thread safety per research pitfall #2).

    5. Update src/commands/mod.rs to expose secrets module.

    All commands use State<'_, Mutex<AppState>> injection pattern from research.
  </action>
  <verify>
    `cd /Users/neosapien/dev/aios/apps/desktop/src-tauri && cargo check` compiles. Optionally write a quick integration test or use `cargo test` if test is added.
  </verify>
  <done>KeyringService CRUD operations work. IPC commands for get_secrets, set_secret, delete_secret exist and compile.</done>
</task>

<task type="auto">
  <name>Task 2: SQLite database initialization and wiring into Tauri builder</name>
  <files>
    apps/desktop/src-tauri/src/lib.rs
    apps/desktop/src-tauri/capabilities/default.json
  </files>
  <action>
    1. Update src/lib.rs:
       - Add tauri-plugin-sql with SQLite migrations:
         ```
         Migration version 1: "create_initial_tables"
         CREATE TABLE IF NOT EXISTS runs (
           id TEXT PRIMARY KEY,
           task TEXT NOT NULL,
           status TEXT NOT NULL DEFAULT 'pending',
           started_at TEXT NOT NULL,
           completed_at TEXT,
           error TEXT
         );
         CREATE TABLE IF NOT EXISTS messages (
           id INTEGER PRIMARY KEY AUTOINCREMENT,
           run_id TEXT NOT NULL,
           role TEXT NOT NULL,
           content TEXT NOT NULL,
           created_at TEXT NOT NULL DEFAULT (datetime('now')),
           FOREIGN KEY(run_id) REFERENCES runs(id)
         );
         ```
       - Use TEXT for timestamps (ISO 8601 strings) -- SQLite best practice
       - Use TEXT for run id (UUID format for uniqueness)
       - Database path: "sqlite:aios.db" (stored in app data directory by plugin)

    2. Initialize AppState with KeyringService in setup closure, manage via app.manage().

    3. Register ALL commands in single generate_handler! macro:
       - commands::health::health_check
       - commands::secrets::get_secrets
       - commands::secrets::get_secret
       - commands::secrets::set_secret
       - commands::secrets::delete_secret

    4. Update capabilities/default.json: Add allow permissions for all secret commands.

    5. Add `mod services;` to lib.rs module declarations.

    IMPORTANT: The key list file for KeyringService should be stored in the app's data directory. Use tauri::api::path::app_data_dir or app.path().app_data_dir() to get the path. Pass this path when constructing KeyringService in setup.
  </action>
  <verify>
    `cd /Users/neosapien/dev/aios/apps/desktop/src-tauri && cargo build` succeeds. Run `pnpm tauri dev` and check that aios.db file is created in the app data directory. Verify the tables exist by checking the SQLite file with `sqlite3` CLI if available.
  </verify>
  <done>SQLite database auto-creates on launch with runs and messages tables. All secrets IPC commands registered and permitted. AppState properly initialized with KeyringService.</done>
</task>

</tasks>

<verification>
1. `cargo build` succeeds
2. `pnpm tauri dev` launches and creates SQLite database
3. SQLite database has runs and messages tables with correct schema
4. Secrets commands are registered in generate_handler! and permitted in capabilities
</verification>

<success_criteria>
- KeyringService can set/get/delete secrets using system keyring
- Key list persists across app restarts (JSON file in app data dir)
- SQLite database initializes on first launch with runs + messages tables
- All IPC commands compile and are properly registered
</success_criteria>

<output>
After completion, create `.planning/phases/02-tauri-shell/02-02-SUMMARY.md`
</output>
