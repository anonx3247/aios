---
phase: 03-node-backend
plan: 03
type: execute
wave: 2
depends_on: ["03-01", "03-02"]
files_modified:
  - apps/desktop/src-tauri/src/lib.rs
  - apps/desktop/src-tauri/tauri.conf.json
  - apps/desktop/src-tauri/capabilities/default.json
  - apps/desktop/src-tauri/Cargo.toml
autonomous: false

must_haves:
  truths:
    - "Tauri app spawns backend sidecar on startup and discovers its port via stdout parsing"
    - "Frontend can call Node backend HTTP API via the discovered port and receive responses"
    - "Sidecar process terminates cleanly when Tauri app closes (no orphans)"
    - "React app renders in Tauri window with Tailwind styling and shows backend connected"
  artifacts:
    - path: "apps/desktop/src-tauri/src/lib.rs"
      provides: "Sidecar spawn, port discovery, get_backend_port command"
      contains: "BACKEND_PORT:"
    - path: "apps/desktop/src-tauri/tauri.conf.json"
      provides: "externalBin sidecar configuration"
      contains: "externalBin"
    - path: "apps/desktop/src-tauri/capabilities/default.json"
      provides: "Shell execute and HTTP fetch permissions"
      contains: "shell:allow-execute"
    - path: "apps/desktop/src-tauri/Cargo.toml"
      provides: "tauri-plugin-http dependency"
      contains: "tauri-plugin-http"
  key_links:
    - from: "apps/desktop/src-tauri/src/lib.rs"
      to: "apps/backend/src/index.ts stdout"
      via: "stdout parsing of BACKEND_PORT:{port}"
      pattern: "BACKEND_PORT:"
    - from: "apps/desktop/src-tauri/src/lib.rs"
      to: "apps/desktop/src/lib/api.ts"
      via: "get_backend_port Tauri command"
      pattern: "get_backend_port"
    - from: "apps/desktop/src-tauri/tauri.conf.json"
      to: "apps/desktop/src-tauri/binaries/backend"
      via: "externalBin sidecar reference"
      pattern: "binaries/backend"
---

<objective>
Wire the Tauri Rust layer to spawn the Node backend as a sidecar, discover its port via stdout parsing, expose the port to the frontend, and configure all necessary permissions. Verify the full integration end-to-end.

Purpose: This is the critical integration plan that connects backend, Tauri, and frontend. The sidecar must start automatically, communicate its port, and be accessible from React.
Output: Complete sidecar integration with production build verification.
</objective>

<execution_context>
@/Users/neosapien/.claude/get-shit-done/workflows/execute-plan.md
@/Users/neosapien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-node-backend/03-RESEARCH.md
@.planning/phases/03-node-backend/03-01-SUMMARY.md
@.planning/phases/03-node-backend/03-02-SUMMARY.md
@apps/desktop/src-tauri/src/lib.rs
@apps/desktop/src-tauri/tauri.conf.json
@apps/desktop/src-tauri/capabilities/default.json
@apps/desktop/src-tauri/Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Configure Tauri for sidecar and HTTP plugin</name>
  <files>apps/desktop/src-tauri/tauri.conf.json, apps/desktop/src-tauri/capabilities/default.json, apps/desktop/src-tauri/Cargo.toml</files>
  <action>
1. **tauri.conf.json** - Add externalBin to bundle config:
```json
"bundle": {
  "externalBin": ["binaries/backend"],
  ...existing config...
}
```
Tauri automatically appends the target triple suffix when looking for the binary.

2. **capabilities/default.json** - Add shell execute permission for the sidecar and HTTP fetch permission:
Add to the permissions array:
```json
{
  "identifier": "shell:allow-execute",
  "allow": [
    {
      "name": "binaries/backend",
      "sidecar": true,
      "args": true
    }
  ]
},
"http:default",
{
  "identifier": "http:allow-fetch",
  "allow": [
    { "url": "http://localhost:*" }
  ]
}
```

3. **Cargo.toml** - Add tauri-plugin-http dependency:
```toml
tauri-plugin-http = "2"
```
Add it to the `[dependencies]` section (NOT the target-specific section).
  </action>
  <verify>
JSON files are valid: `cd /Users/neosapien/dev/aios/apps/desktop/src-tauri && python3 -c "import json; json.load(open('tauri.conf.json')); json.load(open('capabilities/default.json')); print('JSON valid')"`.
Cargo.toml contains tauri-plugin-http.
  </verify>
  <done>Tauri configured with externalBin for sidecar, shell execute + HTTP fetch permissions, and HTTP plugin Rust dependency.</done>
</task>

<task type="auto">
  <name>Task 2: Implement sidecar spawn and port discovery in Rust</name>
  <files>apps/desktop/src-tauri/src/lib.rs</files>
  <action>
Update lib.rs to add sidecar spawning and port discovery. The existing code has AppState in the state module and uses Mutex. We need to:

1. **Add backend port to AppState:** Read the current state.rs file and add a `backend_port: Arc<Mutex<Option<u16>>>` field. Update AppState::new to initialize it. If state.rs exists, modify it; if AppState is defined elsewhere, find it first by grepping.

2. **Add get_backend_port command:** Create a new command (either in commands/backend.rs or inline in lib.rs):
```rust
#[tauri::command]
fn get_backend_port(state: State<'_, std::sync::Mutex<AppState>>) -> Result<u16, String> {
    let app_state = state.lock().map_err(|e| e.to_string())?;
    app_state.backend_port.lock().unwrap()
        .ok_or_else(|| "Backend not ready".to_string())
}
```
Adjust the type signature to match the existing State wrapper pattern (the current code uses `Mutex<AppState>` as the managed type).

3. **Register HTTP plugin:** Add `.plugin(tauri_plugin_http::init())` to the builder chain.

4. **Spawn sidecar in setup closure:** After existing setup code, add:
```rust
// Spawn backend sidecar
let shell = app.shell();
let sidecar_command = shell.sidecar("binaries/backend")
    .map_err(|e| Box::new(e) as Box<dyn std::error::Error>)?;
let (mut rx, _child) = sidecar_command.spawn()
    .map_err(|e| Box::new(e) as Box<dyn std::error::Error>)?;

// Clone the backend_port Arc for the async task
let port_state = app_state.backend_port.clone();

// Listen for stdout to extract port
tauri::async_runtime::spawn(async move {
    use tauri_plugin_shell::process::CommandEvent;
    while let Some(event) = rx.recv().await {
        match event {
            CommandEvent::Stdout(line) => {
                let line_str = String::from_utf8_lossy(&line);
                if let Some(port_str) = line_str.strip_prefix("BACKEND_PORT:") {
                    if let Ok(port) = port_str.trim().parse::<u16>() {
                        *port_state.lock().unwrap() = Some(port);
                        println!("[Tauri] Backend ready on port {}", port);
                    }
                }
            }
            CommandEvent::Stderr(line) => {
                eprintln!("[Backend] {}", String::from_utf8_lossy(&line));
            }
            CommandEvent::Error(err) => {
                eprintln!("[Backend] Error: {}", err);
            }
            CommandEvent::Terminated(payload) => {
                eprintln!("[Backend] Terminated: {:?}", payload.code);
                break;
            }
            _ => {}
        }
    }
});
```

5. **Register get_backend_port command:** Add it to the `generate_handler![]` macro.

6. **Important:** The `_child` handle from sidecar spawn uses kill_on_drop by default in the shell plugin. Store it somewhere it won't be dropped (e.g., in AppState or a separate managed state) OR verify that the async task holding `rx` keeps the process alive. If the child is dropped immediately, the process may be killed. Store the child handle: add a field to AppState like `sidecar_child: Arc<Mutex<Option<tauri_plugin_shell::process::CommandChild>>>` and store `_child` there.

**Critical:** Read the existing state.rs and commands/ directory first to understand the exact type signatures before modifying. The changes must be compatible with the existing `Mutex<AppState>` pattern.
  </action>
  <verify>
`cd /Users/neosapien/dev/aios/apps/desktop && pnpm tauri build` compiles successfully (requires backend binary to exist in binaries/ from plan 03-01).
If full build is too slow, verify with `cd apps/desktop/src-tauri && cargo check` first.
  </verify>
  <done>Rust layer spawns backend sidecar on app startup, parses BACKEND_PORT from stdout, stores port in state, exposes get_backend_port command to frontend.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete Node backend sidecar integration: backend compiles to binary, Tauri spawns it on startup, frontend connects and shows status.</what-built>
  <how-to-verify>
1. Build the backend binary: `cd /Users/neosapien/dev/aios && pnpm --filter @aios/backend build:binary`
2. Build and run the Tauri app: `cd apps/desktop && pnpm tauri build` then run the built app from target/release/bundle
3. OR run in dev mode: start backend separately (`pnpm --filter @aios/backend dev`) then `cd apps/desktop && pnpm tauri dev`
4. Verify: Tauri window shows "AIOS" heading with "Backend connected" in green text
5. Check Activity Monitor / ps: no orphan backend processes after closing the app
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues</resume-signal>
</task>

</tasks>

<verification>
1. `cargo check` in src-tauri passes
2. tauri.conf.json has externalBin configured
3. capabilities have shell:allow-execute and http:allow-fetch
4. get_backend_port command is registered and returns port
5. Production build runs with sidecar starting automatically
6. No orphan processes after app close
</verification>

<success_criteria>
Full sidecar lifecycle works: Tauri starts backend binary, discovers port, frontend connects via HTTP, process cleans up on exit. All Phase 3 success criteria met.
</success_criteria>

<output>
After completion, create `.planning/phases/03-node-backend/03-03-SUMMARY.md`
</output>
