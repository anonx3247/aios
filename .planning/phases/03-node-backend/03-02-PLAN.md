---
phase: 03-node-backend
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/desktop/src/lib/api.ts
  - apps/desktop/src/App.tsx
  - apps/desktop/package.json
autonomous: true

must_haves:
  truths:
    - "Frontend has an API client that fetches backend port via Tauri invoke and calls HTTP endpoints"
    - "App.tsx shows backend connection status (connecting, connected, error) with retry logic"
    - "React app renders in Tauri window with Tailwind styling"
  artifacts:
    - path: "apps/desktop/src/lib/api.ts"
      provides: "Backend HTTP client with port discovery and retry"
      exports: ["backend", "BackendClient"]
    - path: "apps/desktop/src/App.tsx"
      provides: "React root with backend status display"
      contains: "healthCheck"
    - path: "apps/desktop/package.json"
      provides: "@tauri-apps/plugin-http dependency"
      contains: "@tauri-apps/plugin-http"
  key_links:
    - from: "apps/desktop/src/lib/api.ts"
      to: "get_backend_port Tauri command"
      via: "invoke from @tauri-apps/api/core"
      pattern: "invoke.*get_backend_port"
    - from: "apps/desktop/src/App.tsx"
      to: "apps/desktop/src/lib/api.ts"
      via: "import healthCheck or backend"
      pattern: "import.*api"
---

<objective>
Create the frontend API client and update App.tsx to display backend connection status with retry logic. Install the Tauri HTTP plugin on the frontend side.

Purpose: The frontend needs to communicate with the Node backend via HTTP. The API client handles port discovery (via Tauri invoke) and provides a typed interface for backend calls.
Output: Working API client module and App.tsx with live backend status indicator.
</objective>

<execution_context>
@/Users/neosapien/.claude/get-shit-done/workflows/execute-plan.md
@/Users/neosapien/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-node-backend/03-RESEARCH.md
@apps/desktop/src/App.tsx
@apps/desktop/package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install HTTP plugin and create API client</name>
  <files>apps/desktop/package.json, apps/desktop/src/lib/api.ts</files>
  <action>
1. Install `@tauri-apps/plugin-http` in the desktop package:
   `pnpm --filter @aios/desktop add @tauri-apps/plugin-http`

2. Create apps/desktop/src/lib/api.ts with a BackendClient class:

The client must:
- Use `invoke<number>('get_backend_port')` from `@tauri-apps/api/core` to discover the backend port
- Cache the port after first discovery to avoid repeated invokes
- Use a portPromise to prevent race conditions from multiple simultaneous getPort() calls
- Use `fetch` from `@tauri-apps/plugin-http` to make requests (bypasses CORS)
- Provide a generic `call<T>(endpoint, init?)` method that builds the full URL
- Set Content-Type: application/json header by default
- Throw descriptive errors on non-ok responses
- Provide `healthCheck()` convenience method returning `{ status: string; timestamp: number; uptime: number }`
- Export a singleton `backend` instance

**Development mode fallback:** When `get_backend_port` invoke fails (e.g., running in dev without sidecar), fall back to `http://localhost:3001` (the default dev port). Wrap the invoke in try/catch, and on error set port to 3001 and log a warning.

Follow the exact pattern from 03-RESEARCH.md "Frontend API Client with Retry Logic" but add the dev fallback.
  </action>
  <verify>
File exists at apps/desktop/src/lib/api.ts.
`pnpm --filter @aios/desktop build` compiles without TypeScript errors (the Tauri invoke types may show warnings in isolation but should compile).
  </verify>
  <done>API client module created with port discovery, HTTP plugin fetch, error handling, dev fallback, and healthCheck method.</done>
</task>

<task type="auto">
  <name>Task 2: Update App.tsx with backend connection status</name>
  <files>apps/desktop/src/App.tsx</files>
  <action>
Update apps/desktop/src/App.tsx to:

1. Import `useState`, `useEffect` from react
2. Import `backend` from `./lib/api`
3. Add state for status: `'connecting' | 'connected' | 'error'` (initial: 'connecting')
4. Add state for error message string
5. Add useEffect that:
   - Uses a `mounted` flag for cleanup
   - Has retry logic: up to 10 attempts with exponential backoff (1s * attempt)
   - Calls `backend.healthCheck()` in a loop
   - On success: set status to 'connected'
   - On failure after max retries: set status to 'error' with message
6. Keep the existing AIOS heading and description
7. Add status indicator below the description:
   - connecting: yellow text "Connecting to backend..."
   - connected: green text "Backend connected"
   - error: red text "Backend error: {message}"
8. Use Tailwind classes matching the existing dark theme (bg-zinc-950, text-white)

Follow the exact React component pattern from 03-RESEARCH.md "React Component with Backend Connection Status".
  </action>
  <verify>
`pnpm --filter @aios/desktop build` compiles without errors.
File contains import of backend from lib/api, useEffect with retry logic, and three status display states.
  </verify>
  <done>App.tsx renders AIOS heading with live backend connection status indicator using retry logic.</done>
</task>

</tasks>

<verification>
1. `pnpm --filter @aios/desktop build` compiles without errors
2. api.ts exports BackendClient with getPort, call, healthCheck methods
3. App.tsx imports and uses the API client with retry logic
4. @tauri-apps/plugin-http is in package.json dependencies
</verification>

<success_criteria>
Frontend has a complete API client layer and App.tsx displays backend connection status. The UI maintains Tailwind dark theme styling.
</success_criteria>

<output>
After completion, create `.planning/phases/03-node-backend/03-02-SUMMARY.md`
</output>
